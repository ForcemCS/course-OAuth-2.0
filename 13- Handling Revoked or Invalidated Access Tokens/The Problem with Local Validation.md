## The Problem with Local Validation

下边的内容与我们之前讨论的“使用API网关实现分层防御”的思想是**一脉相承**的，只是这次是从**API内部逻辑**的角度来阐述。

### 核心问题：本地验证的“阿喀琉斯之踵”

> 一个奇怪的处境：关于一个令牌是否被撤销的信息，永远不可能存在于令牌自身内部。

- **问题的本质**：
  - JWT令牌是一个**“离线的、一次性签发的快照”**。它只记录了**签发那一刻**的状态。
  - 而令牌的**“撤销状态”**，是一个**动态的、实时变化的、存在于授权服务器数据库中**的状态。
  - 当你只进行本地验证时，你是在用一个**“静态的过去”**去判断一个**“动态的现在”**，这必然会产生信息差。
- **一个生动的例子**：
  1. **9:00 AM**: Auth0颁发了一个有效期8小时的JWT给某个应用。
  2. **9:05 AM**: 应用拿着这个JWT成功调用了你的FastAPI。你的API在本地验证了签名和有效期，一切正常，返回了数据。
  3. **10:00 AM**: 用户在Auth0的设置页面，撤销了对这个应用的授权。**Auth0在自己的数据库里将这个授权记录标记为“已撤销”**。
  4. **10:05 AM**: 应用**依然持有那个看起来完全有效的JWT**（因为它还有7个小时才过期），再次调用你的FastAPI。
  5. **问题出现**：你的FastAPI再次进行**本地验证**。它只检查签名和有效期，发现**一切正常**！于是，它**错误地**为一个已经被撤销授权的请求返回了数据。

### 解决方案：放弃“一刀切”，拥抱“具体问题具体分析”

> 这真的归结为一个判断。你可以根据手头特定的API操作，结合上下文来选择最好的方法。

这节提出的解决方案，不是一个技术工具，而是一种**设计哲学**：**基于风险的、分层级的验证策略**。

你不需要为你的整个API系统选择“要么全本地，要么全远程”。你应该为**每一个API端点**，根据其业务的敏感度，来决定采用哪种验证级别。

### 一个银行App的绝佳案例

银行App的例子，完美地展示了这种分层策略：

#### 场景一：查询账户摘要 (低风险)

- **API端点**：`GET /api/accounts/summary` (返回账户列表和余额)
- **调用频率**：非常高，是App打开后第一个调用的接口。
- 风险评估：
  - 数据敏感度：中等。
  - 如果用一个刚刚被撤销的令牌看到了账户余额，会怎么样？用户（或攻击者）可能已经通过之前的合法请求看到过这些数据了。新信息泄露的风险相对较低。
- **验证策略**：**只进行快速的本地JWT验证。**
- **理由**：为了保证App首页的加载速度和流畅体验，我们可以接受这里极小的“信息过时”风险。

#### 场景二：查询交易详情 (中等风险)

- **API端点**：`GET /api/accounts/{id}/transactions` (返回详细的交易流水)
- **调用频率**：中等。
- 风险评估：
  - 数据敏感度：较高，包含详细的消费记录。
- **验证策略**：可能依然只使用本地验证，但依赖于一个**相对较短的令牌生命周期**（比如15分钟）来控制风险。

#### 场景三：转账 (极高风险)

- **API端点**：`POST /api/transfers`

- **调用频率**：低。

- 风险评估：

  - 数据敏感度/操作风险：**极高！** 你绝对、绝对不希望在一个已被撤销的授权下执行一笔转账操作。

- 验证策略：

  混合验证！

  1. 首先，进行**本地JWT验证**，快速过滤掉伪造或过期的令牌。
  2. 如果本地验证通过，**在执行转账逻辑之前**，必须再进行一次**远程令牌内省**，去向授权服务器做最后的、实时的确认：“这个令牌现在这一刻，真的还是有效的吗？”
  3. 只有当远程内省也返回`"active": true`时，才继续执行转账操作。

- **理由**：对于这种高风险操作，**安全性远比那一点点的性能延迟更重要**。我们愿意为了100%的确定性，而付出一次网络请求的代价。

### 总结

作为API开发者，你在令牌验证上拥有**灵活的决策权**。

1. **本地验证的根本问题**：它无法感知到令牌的**实时撤销状态**。
2. **没有银弹**：不存在一个既能100%实时验证又能零网络开销的完美方案。
3. 最佳实践是“混合与权衡”：
   - 将**本地验证**作为**默认的、高性能的**第一道防线，用于处理大部分低风险请求。
   - 将**远程内省**作为**可选的、高安全的**“终极保险”，仅用于保护那些绝对不能出错的、高风险的API端点。

这种基于**业务风险评估**来动态选择验证策略的方法，是构建一个既安全又高效的现代API系统的精髓所在。