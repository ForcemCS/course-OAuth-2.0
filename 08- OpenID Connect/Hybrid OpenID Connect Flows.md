## Hybrid OpenID Connect Flows

我们将探讨OpenID Connect中一个比较高级、也比较复杂的概念——**混合流程 (Hybrid Flows)**。

### 什么是混合流程？

“混合”指的是在`response_type`参数中，**组合多个期望的返回值**。

我们之前所讨论过的：

- `response_type=code`：我想要一个**授权码 (`code`)**。
- `response_type=id_token`：我想要一个**ID令牌 (`id_token`)**。
- `response_type=token`：(OAuth隐式流) 我想要一个**访问令牌 (`access_token`)**。

**混合流程**就是把它们用空格或加号组合起来，比如：

- `response_type=code id_token`
- `response_type=code token`
- `response_type=code id_token token`

**任何包含`token`的`response_type`组合，我们都应该忽略和避免使用。**

### 重点分析：`response_type=code id_token`

这个流程是混合流程中最有代表性的。我们来详细拆解它的工作方式和优缺点。

- **它的意图**：

  - “我希望在**前通道**的重定向中，**立刻**拿到`ID Token`。”
  - “同时，我也希望拿到一个`code`，以便我之后可以在**后通道**中去交换`Access Token`。”

- **流程是怎样的？**

  1. 应用发起授权请求，`response_type`设置为`code id_token`。

  2. 用户在授权服务器登录、同意。

  3. 授权服务器将用户重定向回应用，这次返回的URL中会同时包含`code`和`id_token`。

     > `https://app.com/callback?code=...&id_token=...` (这只是示意，实际可能在片段`#`中)

  4. **应用在前台立刻拿到了`ID Token`**。

  5. 应用同时拿到了`code`，然后它再通过**后台**去交换`Access Token`。

- **优点（理论上的）**：

  - **提前获取用户信息**：应用可以在**不等后通道的`Access Token`交换完成之前**，就立刻从前通道拿到的`ID Token`中解析出用户信息（如`sub`、`name`）。在某些对性能要求极高的场景下，这微小的提前量可能有用。

- **缺点和复杂性（巨大的）**：

  1. **必须进行严格的`ID Token`验证**：
     - 因为这个`ID Token`是通过不安全的前通道获取的，所以应用**必须**对它进行完整的、严格的签名和声明验证，才能安全地使用它。这增加了客户端的实现复杂度。
  2. **需要额外的`c_hash`验证**：
     - 为了防止在这次复杂的返回中，`code`被篡改（而`id_token`没被篡改），OIDC为这个流程设计了一个额外的声明：**`c_hash` (Code Hash)**。

- `c_hash`是授权服务器对它即将颁发的`code`进行特定哈希运算后得到的值。
- 客户端在收到`code`和`id_token`后，**必须自己**对收到的`code`进行同样的哈希运算，然后与`id_token`里的`c_hash`进行比对。
- **如果匹配**，才能证明收到的`code`和`id_token`是“原配的一对”，没有在传输中被掉包。这又大大增加了客户端的验证负担。

### 最终的、来自官方的建议：回归简单与安全

分析完混合流程的复杂性后，给出了一个非常明确的结论，这也是当前**OAuth工作组的最新指导意见**：

> **与其使用这些复杂的、需要客户端自己承担大量验证责任的混合流程，不如回归到最简单、最安全的那个流程。**

**这个最佳流程就是：**

**带PKCE的授权码流程 (`response_type=code` + PKCE参数)，并同时请求`openid` scope。**

- **为什么这个流程是最好的？**
  1. **安全性由服务器保障**：
     - 混合流程中的`c_hash`等机制，是把**防止攻击的责任“下放”给了客户端**。授权服务器无法保证每个客户端都正确地实现了这些复杂的验证。
     - 而**PKCE**，是把**防止授权码注入攻击的责任“上收”到了授权服务器**。服务器在交换`code`时会强制验证`code_verifier`，如果验证失败，请求就直接被拒绝。**服务器从源头上保证了安全**，而不用去信任每个客户端的实现。
  2. **客户端实现最简单**：
     - 客户端开发者不需要去处理`c_hash`，也不需要在前通道处理`ID Token`。
     - 他们只需要走一个标准的、单一的流程，然后在**一个安全的后通道响应中，一次性拿到所有需要的令牌 (`Access Token`和`ID Token`)**。
     - 这大大降低了开发者的心智负担和出错的可能性。
  3. **通用性最强**：
     - 这个流程对**所有类型**的客户端（机密的和公共的）都是最佳实践。