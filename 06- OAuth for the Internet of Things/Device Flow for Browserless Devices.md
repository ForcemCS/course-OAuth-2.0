## Device Flow for Browserless Devices

### 核心思想：两个设备，两条并行的故事线，一个服务器中介

这个流程最独特的地方在于，它将用户的一次登录行为，分成了两个设备上同时发生的两条故事线：

1. **故事线一 (在目标设备上)**：你的智能电视/物联网设备在**后台**与服务器进行**机器间的对话**。
2. **故事线二 (在输入设备上)**：你（用户）在**前台**用手机/电脑与服务器进行**人机交互**。

这两条故事线通过**授权服务器**这个“中央协调员”联系在一起。

### 流程详解：每一步的API请求和响应

#### 第一步：目标设备发起流程（“我想让人登录”）

1. **触发**：用户在智能电视上点击“登录”。

2. **动作**：电视App向授权服务器的一个**新的、专门的端点**（通常叫`device_authorization_endpoint`）发起一个**POST请求**。

3. 请求内容

   ：这个请求非常简单，因为它几乎一无所知。

   - `client_id={YOUR_CLIENT_ID}`: “我是XX电视App。”
   - `scope={DESIRED_SCOPES}`: (可选) “我希望能有‘读写播放列表’的权限。”

4. 服务器响应 (关键的指令集)

   ：授权服务器收到请求后，返回一个JSON对象，里面包含了所有后续操作需要的指令。

   ```json
   {
     "device_code": "a_very_long_secret_code_for_the_device", // 设备码
     "user_code": "ABCD-EFGH",                              // 用户码
     "verification_uri": "https://example.com/activate",    // 验证URL
     "interval": 5,                                         // 轮询间隔（秒）
     "expires_in": 900                                      // 整个流程的有效期（秒）
   }
   ```

   - **`device_code`**: 一个**长**的、随机的字符串。这是电视的**秘密凭证**，用来在后台轮询时证明自己的身份。
   - **`user_code`**: 一个**短**的、易于输入的字符串。这是给**用户看和输入**的。
   - **`verification_uri`**: 用户需要在手机上访问的地址。
   - **`interval`**: 告诉电视“每隔5秒来问我一次”。
   - **`expires_in`**: 告诉电视“如果用户在900秒（15分钟）内没完成操作，这次的`device_code`和`user_code`就作废了，你得从头再来。”

### 第二步：两条故事线并行展开

在电视拿到上面的指令后，两条故事线同时开始：

#### 故事线一：电视在后台的“耐心等待” (轮询)

1. **显示信息**：电视在屏幕上清晰地展示`user_code` ("ABCD-EFGH") 和 `verification_uri` ("https://example.com/activate")。
2. 开始轮询 (Polling)：
   - 电视启动一个定时器。
   - 每隔`interval`（5）秒，它就向授权服务器的**令牌端点 (`/token`)** 发起一个**POST请求**。
   - 请求内容:
     - `grant_type=urn:ietf:params:oauth:grant-type:device_code`: 一个特殊的`grant_type`，表明“我是在用设备码轮询”。
     - `device_code={THE_LONG_DEVICE_CODE}`: “这是我的秘密凭证。”
     - `client_id={YOUR_CLIENT_ID}`
   - **服务器的初期响应**：在用户完成授权前，服务器每次都会返回一个错误，比如`authorization_pending`，意思是“别急，用户还在弄呢，你过会儿再来问。”

#### 故事线二：用户在前台的“轻松操作”

1. **用户拿出手机**，打开浏览器，输入`verification_uri`。
2. 浏览器打开一个页面，提示“请输入您在设备上看到的激活码”。
3. 用户输入`user_code` ("ABCD-EFGH")。
4. 授权服务器通过`user_code`，知道了用户现在是想为哪个`device_code`（即哪台电视）进行授权。
5. **进入标准登录流程**：现在，用户的手机上会展现一个**完全正常的登录和授权流程**。他可以输入密码、进行多因素认证（MFA）、使用WebAuthn，或者“使用Apple登录”等。**所有复杂的认证都在功能强大的手机上完成**。
6. 用户登录成功后，看到一个**同意页面**：“XX电视App 正在申请访问您的账户，是否允许？”
7. 用户点击“允许”。
8. 手机上显示“成功！您的设备现已连接。” **用户在手机上的任务到此结束。**

### 第三步：故事线汇合，电视获取令牌

1. 当用户在手机上点击“允许”后，授权服务器在后台将与`device_code`关联的状态标记为“已授权”。

2. **电视的下一次轮询**：当电视再次带着`device_code`来轮询时，授权服务器发现状态已经变了。

3. 成功的响应：这一次，服务器不再返回`authorization_pending`错误，而是返回一个标准的、成功的令牌响应，就像其他OAuth流程一样：

   ```json
   {
     "access_token": "a_long_access_token_string",
     "token_type": "Bearer",
     "expires_in": 3600,
     "refresh_token": "a_very_important_refresh_token" // 通常会包含
   }
   ```

4. **流程结束**：电视拿到了`access_token`，停止轮询，界面刷新为已登录状态。它现在可以使用这个令牌去访问API了。

### 为什么刷新令牌 (Refresh Token) 在这里更重要？

- 整个设备授权流程对于用户来说，虽然比用遥控器输密码好得多，但依然是一个相对“重”的操作（需要拿出手机、输入网址和代码）。
- 如果`access_token`（比如1小时后）过期了，你绝对不希望让用户再来一遍这个流程。
- 因此，对于设备流来说，授权服务器**几乎总会**在第一次成功时返回一个**长生命周期的`refresh_token`**。
- 这样，电视App就可以在后台静默地、永久地使用`refresh_token`来换取新的`access_token`，实现“登录一次，永久有效”的体验。这也是为什么你在Apple TV上登录Netflix等应用后，就几乎再也不用重新登录的原因。