## Protecting Tokens in the Browser

**在拿到了`Access Token`之后，我该把它存放在浏览器的哪个地方才最安全？**PKCE保护的是“过程”，现在我们要保护“结果”

- **PKCE的职责**：保护**授权流程本身**的安全。它确保了只有你的应用能用`code`换回`token`，防止了授权码被劫持。
- **新的挑战**：一旦流程结束，你的JavaScript代码成功拿到了`access_token`，PKCE的任务就完成了。现在，难题变成了：**如何安全地保管这个刚刚到手的、非常有价值的`token`？**

由于浏览器环境的固有风险（特别是XSS攻击），任何能被你合法JS代码访问到的地方，也同样能被攻击者的恶意JS代码访问到。

### 浏览器中的存储选项分析

#### 1. `LocalStorage` 和 `SessionStorage`

- `LocalStorage`：
  - **特点**：持久化存储。关闭浏览器再打开，数据依然存在。同一域名下的多个标签页共享数据。
  - **`SessionStorage`**：
  - **特点**：会话级存储。关闭标签页或浏览器，数据就被清除。每个标签页有自己独立的存储空间，不共享。
- 共同的、致命的弱点：
  - **完全暴露给JavaScript**：任何能在这个页面上运行的JS代码，都可以轻松地通过`localStorage.getItem('access_token')`来读取其中的内容。
  - **XSS攻击的重灾区**：如果你的网站存在XSS漏洞，攻击者注入的脚本第一件事往往就是遍历`localStorage`和`sessionStorage`，窃取所有敏感信息，包括你的令牌。
- **一个重要的澄清**：即使是来自不同域名的JS（比如你引入的第三方广告脚本），一旦它被加载到你的页面上，它就运行在**你的域名上下文**中，因此它也拥有访问你域名下`LocalStorage`的权限。
- **结论**：将令牌以明文形式存储在这两个地方是**最不安全**的做法，尽管它实现起来最简单。

#### 2. `Cookies`

- **特点**：一个更古老的数据存储机制，主要用于让浏览器在每次请求时自动携带数据到后端。
- **弱点**：同样可以被JavaScript访问（除非设置了`HttpOnly`标志）。如果JS能访问，那么它也面临和`LocalStorage`一样的XSS风险。如果设置了`HttpOnly`，那你的SPA的JS代码自己就无法读取和使用这个令牌了，这通常不适用于纯前端的SPA架构。

### 更有前景的、但更复杂的替代方案

#### 方案A：存储在内存中 (In-Memory Storage)

- **做法**：将获取到的`access_token`存储在一个JavaScript的**全局变量或闭包**中。
- 优点：
  - **大大提升了安全性**：令牌不被写入任何持久化存储。攻击者即使能注入脚本，也很难直接从内存中定位和提取一个变量的值，比读取`localStorage`困难得多。
- 缺点：
  - **用户体验差**：用户只要**刷新页面**或**关闭标签页**，内存中的令牌就会丢失。这意味着用户每次刷新页面都**需要重新登录**。
  - **无法跨标签页共享**：在一个标签页登录后，打开一个新的标签页仍然是未登录状态。
- **结论**：安全性高，但牺牲了用户体验，通常不适用于需要持久登录的应用。

#### 方案B：存储在Service Worker中

- **什么是Service Worker**：一个可以在后台独立于主浏览器窗口运行的JavaScript脚本，通常用于实现离线缓存、推送通知等功能。
- 做法：
  1. 让**Service Worker**去完成整个OAuth流程，获取并存储令牌。
  2. 令牌被存储在Service Worker的**独立作用域**内。
  3. 你的主应用JS代码**永远看不到**`access_token`。
  4. 当主应用需要调用API时，它不是自己发请求，而是**向Service Worker发送一个消息**：“嘿，请帮我调用`/api/users/me`这个接口。”
  5. Service Worker收到消息后，自己附上令牌，发起API请求，然后把结果再通过消息传回给主应用。
- 优点：
  - **极高的安全性**：Service Worker的存储和运行环境与主页面是**完全隔离的**。页面上的XSS攻击**无法访问**到Service Worker中存储的令牌。
- 缺点：
  - **实现复杂**：这彻底改变了应用的架构，你需要构建一套基于消息传递的API调用机制。
  - **兼容性问题**：在一些老旧浏览器（如IE11）中不可用。
  - **并未完全解决问题**：攻击者的脚本虽然偷不走令牌，但它仍然可以**冒充你的主应用**，向Service Worker发送消息，让它去发起恶意的API请求。

#### 方案C：使用WebCrypto API进行加密

- **什么是WebCrypto API**：一个浏览器提供的API，允许JavaScript进行加密操作，并且可以生成**不可提取的密钥 (non-extractable keys)**。
- 做法：
  1. 使用WebCrypto API生成一个**不可提取的**加密密钥。这意味着，即使是JS代码本身，也无法读出这个密钥的原始值，只能用它来加密和解密。
  2. 将`access_token`用这个密钥加密后，再存入`localStorage`。
- 优点：
  - 比明文存储安全得多。一个普通的、广撒网式的XSS攻击脚本，即使读取到了加密后的令牌，也无法使用。
- 缺点：
  - **并非完美**：一个**专门针对你的应用**的、更高级的攻击者，虽然无法提取出密钥，但可以调用解密函数。他可以注入脚本，读取加密的令牌，然后调用你的解密逻辑，从而得到明文令牌。
  - **兼容性问题**：这个特定的API在Safari的某些版本和所有IE版本中不可用。

之后我们会介绍一种完全不同的架构，在这种模式下，敏感的`access_token`和`refresh_token`将永远停留在**后端服务器**，而浏览器中的JavaScript只会持有一些安全性较低的凭证（比如一个普通的会话Cookie）。这就是所谓的**BFF (Backend for Frontend)** 模式。