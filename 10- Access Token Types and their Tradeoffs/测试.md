## 用户实体

### 1. 用户 (User)

- **指代对象**：**人类，最终的使用者**。比如你的运维工程师`Alice`，或者一个普通的网民`张三`。
- 在系统中的角色：
  - **资源的所有者 (Resource Owner)**：他们拥有自己的数据（如个人资料、照片、云盘文件）。
  - **认证的主体 (Authentication Subject)**：他们是那个需要通过输入密码、短信验证码、或Face ID来证明自己身份的人。
- **你在Auth0中的操作**：你会在"User Management" -> "Users"这个菜单下，创建、管理这些真实的用户账号。

------

### 2. 应用 (Application)

- **指代对象**：**想要代表用户（或代表自己）去访问API的程序代码**。它是一个**客户端 (Client)**。

- **在系统中的角色**：

  - **发起者 (Initiator)**：它启动OAuth流程，请求授权。
  - **令牌的持有者和使用者**：它最终会拿到`Access Token`，并用它去调用API。

- **你在Auth0中的操作**：你会在"Applications" -> "Applications"这个菜单下，根据你程序的类型（SPA, Native App, Web App, M2M）来创建和配置这些“应用”。

  **例如，在你的游戏运维平台项目中：**

  - 你的**React前端**就是一个“应用”。
  - 如果你用了BFF架构，你的**FastAPI BFF**也是一个“应用”。
  - 如果你有一个后台定时任务需要调用API，那个**定时任务脚本**也需要注册成一个“应用”（通常是M2S类型）。

------

### 3. API

- **指代对象**：**一个提供数据或服务的后端接口**，它本身**不发起**OAuth流程，而是**被动地接收和验证**令牌。

- **在系统中的角色**：

  - **资源服务器 (Resource Server)**：它守护着宝贵的资源。
  - **令牌的验证者 (Token Validator)**：它的核心职责是检查收到的`Access Token`是否有效、可信、且有足够权限。

- **你在Auth0中的操作**：你会在"Applications" -> "**APIs**"这个菜单下，专门为它创建一个定义。

  **例如，在你的游戏运维平台项目中：**

  - 你的**FastAPI核心后端**（提供`/servers/reboot`, `/logs/read`等接口的那个），就是一个需要被保护的**API**。

## SPA

```
https://dev-laqpxxuvm0cuwlfe.us.auth0.com/authorize?
    response_type=code&
    client_id=XXXXXXXX&
    state=my_random_test_state_0814&
    scope=scope=openid%20profile%20email& &
    redirect_uri=https://ops.mygame.com/callback&
    code_challenge=XXXXXXXXX&
    code_challenge_method=S256
```

**具体流程是：**

1. 用户在你的React应用界面上点击“登录”。
2. 你的React代码（或者你使用的某个OAuth库，如`keycloak-js``auth0-react`）会执行以下操作：
   - 生成`code_verifier`和`state`，并暂存在浏览器中。
   - 计算出`code_challenge`。
   - 将所有必需的参数（`client_id`, `redirect_uri`, `scope`, `code_challenge`等）拼接成这个长URL。
   - 最后，通过执行`window.location.href = '...'`，让用户的浏览器**跳转**到这个URL。

所以，这个请求的发起者是**前端JavaScript**。

------

### 2. `redirect_uri` 指的是JS前端还是FastAPI后端？

`redirect_uri` 指的是**你的JS前端（React应用）的一个特定路由地址**。

**详细解释：**

- **它的角色是“返程地址”**：当用户在Auth0/Keycloak上成功认证后，授权服务器需要知道把用户的浏览器送回到哪里。
- **处理者是前端**：是你的**React前端应用**需要准备好接收这个返回的请求。因为返回的URL (`https://ops.mygame.com/callback?code=...`)中包含了`code`，而下一步需要用这个`code`去换`token`的逻辑，也是由**前端JS**来发起的。
- 它不是后端地址：
  - 如果`redirect_uri`直接指向你的FastAPI后端，那么用户的浏览器就会被重定向到一个只返回JSON数据的API端点上，用户会看到一堆无意义的文本，而不是你的应用界面。
  - 整个流程的设计是，用户应该始终在**前端应用**的视觉环境中进行操作。登录完成后，他们应该被送回到你的React应用里，然后由React应用在后台完成后续的令牌交换，并最终渲染出已登录的主界面。

**所以，`redirect_uri="https://ops.mygame.com/callback"` 这个地址，意味着：**

1. 你需要在你的React应用中，使用`react-router-dom`这样的库，设置一个路径为`/callback`的路由。
2. 这个路由对应的组件（比如`<CallbackPage />`）的核心任务就是：在页面加载时，从URL中解析出`code`，然后立即向Auth0/Keycloak的`/token`端点发起**后通道**的POST请求，以完成令牌交换。

## 具体步骤

```shell
https://xxxxxxxxxxxxxxx.us.auth0.com/authorize?
    response_type=code&
    client_id=V9D7B7Ix6FRakZQqhrFHoOglXaDdgIRr&
    state=my_random_test_state_0814&
    audience=https://contacts.example.com& 
    scope=openid%20profile%20email& &
    redirect_uri=https://ops.mygame.com/callback&
    code_challenge=xxxxxxxxxxxxxx4&
    code_challenge_method=S256


curl -X POST https://dev-laqpxxuvm0cuwlfe.us.auth0.com/oauth/token \
  -d grant_type=authorization_code \
  -d redirect_uri=https://ops.mygame.com/callback \
  -d client_id=V9D7B7Ix6FRakZQqhrFHoOglXaDdgIRr \
  -d client_secret=eFDb1XQHYnoVxO58GOPU8Hwx9bGBHNkKxD2FSDQpqNHDFymUFbkmtfpZwhd98Pcd \
  -d code_verifier=xxxxxxxxxx \
  -d code=zJW0mFxYL4ytQzdXOfBhTnVPoYusuHGvDjTerHsV9-1xQ
```



### 核心思想：作为API，你必须成为一个严格的“验票员”

现在，你就是那个“门锁”（FastAPI后端）。当有人拿着“房卡”（`Access Token`）来刷门时，你不能轻易就开门。你必须完成一套严格的检查程序。这个练习就是让你手动模拟这套程序。

**使用的工具**：**jwt.io**

- 这是一个非常强大的在线JWT调试工具。它不仅仅是一个解码器，它还是一个**验证器**。

------

### 第一步：验证签名 (Verifying the Signature)

> **"Paste the access token into jwt.io... It will then use a JWT library to validate the signature, and you should see a 'Signature Verified' checkmark."**

- **这是让你做什么？**
  1. 把你上一步获取到的那个**为你的API定制的`Access Token`**（那个`aud`是你API Identifier的令牌）复制出来。
  2. 粘贴到jwt.io网站左边的"Encoded"文本框里。
- **jwt.io在后台做了什么？（这就是你的API未来需要做的）**
  1. **解码Header和Payload**：它自动解码令牌的第一和第二部分，将JSON内容显示在右边。
  2. **找到`iss` (Issuer)**：它从解码后的Payload中找到`iss`声明，比如 `https://dev-laqpxxuvm0cuwlfe.us.auth0.com/`。
  3. **发现公钥地址 (JWKS URI)**：它根据OIDC的“服务发现”规范，自动推断出Auth0存放公钥的地址，通常是 `iss` + `.well-known/jwks.json`。
  4. **获取公钥**：它向这个公钥地址发起一个网络请求，获取到一个公钥列表。
  5. **匹配公钥**：它从令牌的Header中找到`kid`（密钥ID），然后在下载的公钥列表中找到与之匹配的那个公-钥。
  6. **进行数学验证**：它使用这个公钥和Header中声明的算法（`alg`: "RS256"），对令牌的签名（第三部分）进行密码学计算。
  7. **得出结论**：如果计算结果正确，它就会在左下角显示一个绿色的对勾和**“Signature Verified”（签名已验证）**。
- **这一步的意义**：
  - **确认真实性**：证明这个令牌确实是由Auth0签发的，而不是某个攻击者伪造的。
  - **确认完整性**：证明令牌的内容（Header和Payload）从签发到现在，没有被任何人篡改过一个字符。

------

### 第二步：模拟篡改（理解签名的重要性）

> **"To see what happens... change a few characters of your access token claims or signature, and the validation should fail."**

- **这是让你做什么？**
  - 在jwt.io右边的"Decoded"区域，**随便修改Payload里的任何一个字符**。比如，把`scope`里的`"photos"`改成`"videos"`。
  - 你会立刻看到，左下角的提示变成了红色的叉和**“Invalid Signature”（签名无效）**。
- **这一步的意义**：
  - 让你亲身体会到JWT签名的威力。只要令牌内容有**任何一丁点**的改动，签名就会立刻失效。这保证了API收到的令牌信息是绝对可信的。

------

### 第三步：验证核心声明 (Validating the Claims) - 光有真签名还不够

> **"The JWT library will validate the signature and likely the expiration date as well... you may be able to configure it to also validate the 'iss' and 'aud' claim... Your API should only accept access tokens with an 'aud' value that match your API’s identifier."**

- **这是在告诉你什么？**
  - 一个真实的JWT验证库（比如Python的`python-jose`）不仅仅是验证签名。一个完整的、安全的验证过程还**必须包括对Payload中关键声明的检查**。
  - 你的FastAPI后端代码，在调用验证函数时，通常需要传入一些期望值，库会帮你自动检查：
    1. **`exp` (Expiration)**：检查令牌是否已过期。
    2. **`iss` (Issuer)**：检查签发者是否是你信任的那个Auth0地址。
    3. **`aud` (Audience)**：**检查受众是否是你API的Identifier！** 这是防止“拿着食堂饭卡刷金库大门”的关键。
- **这一步的意义**：
  - 确保这张“真的”房卡，不仅没过期，而且确实是“我们酒店前台”发行的，并且明确是“给301房间”使用的。
  - 一个令牌只有在**签名有效**和**所有关键声明都符合预期**的情况下，才能被认为是完全可信的。