## Validating and Using an ID Token

**如何验证和使用ID令牌 (ID Token)**。**你获取ID令牌的方式，直接决定了你验证它的复杂程度。**

```json
{
  "sub": "00uqi4dbxsUVcAi2X356",
  "name": "Aaron Parecki",
  "locale": "en-US",
  "email": "demo@aaronpk.com",
  "ver": 1,
  "iss": "https://pk-demo.okta.com/oauth2/default",
  "aud": "0oa5sso3mrYKdvdE0357",
  "iat": 1602104200,
  "exp": 1602107800,
  "jti": "ID.VymjEpTPYZE TjLmYEDqgANEWQ s5JMT PwaD6te8yTLg",
  "amr": [
    "pwd"
  ],
  "idp": "00oqi4dbxCXNsYWWi356",
  "nonce": "ff935284e4",
  "preferred_username": "demo@aaronpk.com",
  "given_name": "Aaron",
  "family_name": "Parecki",
  "zoneinfo": "America/Los_Angeles",
  "updated_at": 1601943403,
  "email_verified": true,
  "auth_time": 1602104159,
  "c_hash": "ZZJ2X3iKphV9YDhW793jTg"
}
```

### 核心情景：何时必须进行严格验证？

- **场景**：当你使用**隐式流程 (`response_type=id_token`)** 或 **混合流程 (`response_type=code id_token`)** 时，`ID Token`会通过不安全的**前通道**（浏览器地址栏）直接发送给你的应用。
- 为什么必须验证：
  - **来源不可信**：你的应用的回调端点（Callback Endpoint）是暴露在互联网上的。任何攻击者都可以伪造一个请求，直接向你的回调端点“扔”一个他自己编造的、或者从别处偷来的`ID Token`。
  - **你的应用无法分辨**：如果没有严格的验证机制，你的应用看到一个格式正确的JWT，就可能会误以为这是一个合法的登录，从而造成严重的安全漏洞。

### 严格验证的步骤：一个都不能少

当`ID Token`来自不可信的前通道时，你**必须**按照以下顺序进行完整的验证：

#### 第一步：验证签名 (Validate the Signature)

- **目的**：确认令牌的**真实性**和**完整性**。即，它确实是由你信任的授权服务器签发的，并且内容没有被中途篡改。
- 如何做：
  1. 从ID Token的**Header**中获取`kid`（密钥ID）和`alg`（签名算法）。
  2. 根据`kid`，从授权服务器的JWKS端点获取对应的**公钥**。
  3. 使用一个标准的JWT库，将令牌、公钥和算法一起传入验证函数。
  4. **警告**：绝对不要自己手写密码学代码！

#### 第二步：验证核心声明 (Validate the Core Claims)

即使签名验证通过了，也只证明了令牌本身是真的。但这还不够，你还需要确认这个“真的”令牌，是不是**“为你、为此次请求”**颁发的。这可以防止**令牌重放攻击**。

- `iss` (Issuer)：检查签发者是否是你预期的那个授权服务器的地址。

  > 防止有人用一个从其他（可能是恶意的）授权服务器获取的、签名也有效的令牌来欺骗你。

- `aud` (Audience)：检查受众是否是你应用的`client_id`。

  > 防止有人拿着为“应用A”颁发的令牌，来登录你的“应用B”。

- `exp` (Expiration Time) 和 `iat` (Issued At)：检查当前时间是否在令牌的有效期内。

  > 防止使用已过期的令牌。

- `nonce` (Nonce)：极其关键！

  - 在发起授权请求时，你的客户端必须生成一个一次性的随机字符串（`nonce`）并包含在请求中。
  - 授权服务器会原封不动地把这个`nonce`放回到`ID Token`的Payload里。
  - 你的客户端在验证时，**必须**检查返回的`nonce`是否与当初自己生成并存储的那个`nonce`完全匹配。
  - **作用**：它将这个收到的`ID Token`与你当初发起的**那一次特定**的授权请求**绑定**在了一起，确保这个令牌不是从其他流程中被截获并“重放”给你的。

### 验证通过后：现在可以安全地使用信息了

只有在完成了上述所有验证步骤之后，你才能**信任**`ID Token`里的其他信息。

- **`sub` (Subject)**：现在你可以安全地用这个用户ID来识别用户，并在你的数据库中查找或创建用户记录。
- **`name`, `email`等个人信息**：现在可以安全地使用它们来更新用户资料或在UI上显示。
- 其他高级声明：
  - **`amr` (Authentication Methods References)**：一个数组，告诉你用户是通过什么方式登录的。比如`["pwd"]`表示密码，`["mfa"]"]`表示多因素认证。你的应用可以根据这个值来强制要求更高的安全级别。
  - **`auth_time`**：用户上次认证的时间。你的应用可以用它来判断用户是否需要“重新认证”（比如，在进行高风险操作前，如果`auth_time`已经很旧了，可以强制用户再次输入密码）。

### 一个“捷径”：后通道获取ID令牌

- **场景**：当你使用`response_type=code`并附带`scope=openid`时，`ID Token`是在一个安全的、可信的**后通道**中返回的。
- 为什么可以“跳过”验证？
  - **签名验证**：因为你通过HTTPS直接与授权服务器通信，连接本身是加密和受信任的，所以可以认为令牌没有被篡改。
  - **`iss`验证**：你知道你正在和哪个服务器对话，所以来源是可信的。
  - **`aud`验证**：你用你的`client_id`和`client_secret`（如果是机密客户端）去交换令牌，服务器不会发给你一个给别人的令牌。
  - **`nonce`验证**：这个保护由`Authorization Code`本身的一次性使用特性和PKCE提供了更强的保障。
- **结论**：授权码流程极大地**简化了客户端的工作**，因为它将大部分验证的复杂性通过流程本身的安全性解决了。

### 何时需要重新验证？

课程最后提出了一个重要观点：**令牌的“可信度”取决于它的来源。**

- 场景一：你通过授权码流程在后端拿到了`ID Token`，立即解析出用户信息，然后立即丢弃这个`ID Token`。
  - **验证**：你只需要做这一次隐式的信任即可。
- 场景二：你把`ID Token`存储了起来（比如存在一个客户端的Cookie里），然后在后续的请求中，这个`ID Token`从用户的浏览器再次被发送到你的后端。
  - **验证**：此刻，这个`ID Token`的来源变成了**“不可信的”浏览器**。你的后端在每次收到它时，都**必须重新进行完整的签名和声明验证**，才能再次信任它。

**最终建议**：为了简单和安全，尽量使用**授权码流程**，在后通道获取`ID Token`，**一次性使用**其中的信息，然后就忘记它。这是最稳妥的实践。