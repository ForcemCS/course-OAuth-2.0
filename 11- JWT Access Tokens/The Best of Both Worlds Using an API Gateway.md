## The Best of Both Worlds: Using an API Gateway

**分层防御，按需验证，用性能换取极致安全。**

### 核心问题：两难的抉择

我们之前面临的困境：

- 方案一：纯本地验证 (JWT)
  - **优点**：速度极快，可扩展性强。
  - **缺点**：无法感知到令牌被**撤销**，可能依赖**过时的信息**做决策。
- 方案二：纯远程内省
  - **优点**：能获取令牌的**实时状态**，绝对安全。
  - **缺点**：性能差，每次请求都增加网络延迟，授权服务器成为瓶颈。

我们不想在“快但不完美”和“完美但慢”之间二选一。我们需要一个能**“取其精华，去其糟粕”**的方案。

### 解决方案：引入API网关，实现分层验证

这节课提出的解决方案，就是引入一个**API网关 (API Gateway)** 作为整个后端系统的统一入口。

**API网关是什么？**
它是一个位于客户端和你的所有后端微服务之间的服务器。所有外部请求都必须先经过网关，再由网关路由到相应的后端服务。

在这个新的架构下，令牌验证被分成了**两个层次**：

#### 第一层：在API网关进行“快速的、粗略的”验证

1. **角色**：API网关是你的**第一道防线**。它需要处理来自互联网的所有流量，包括合法的、恶意的、格式错误的、过期的等等。
2. **验证方法**：网关**只进行本地JWT验证**。
3. 它能做什么？
   - 极速过滤：它可以非常快地拒绝掉大量的无效请求：
     - 格式错误的令牌。
     - 签名无效的伪造令牌。
     - **已过期的令牌**。
   - **提升性能**：通过本地验证，它不会给每个请求增加网络延迟。
   - **保护后端**：它像一个强大的盾牌，将绝大多数垃圾流量挡在了外面，大大减轻了后端核心API的压力。
4. 它不能做什么？
   - 它**无法识别出那些“虽然还没过期，但已经被撤销”的令牌**。
   - 因此，它会把两种请求放行到后端：
     1. **完全有效的请求**。
     2. **携带“已撤销但未过期”令牌的请求**。

#### 第二层：在核心API进行“可选的、精确的”验证

1. **角色**：后端的核心API（比如你的FastAPI应用）现在只接收经过网关初步筛选过的、“看起来”合法的请求。
2. **决策权**：现在，**决定权交给了每一个具体的API端点**。API的开发者可以根据业务的**敏感度**，来决定是否需要进行第二层、更严格的验证。
3. 两种处理策略：
   - **对于低风险操作**：
     - **例子**：一个查询用户当前游戏积分的API。
     - **决策**：“即使这个令牌在半小时前被撤销了，用户多看到了半小时前的积分，风险也可以接受。”
     - **动作**：这个API端点**信任网关的本地验证结果**，不再做任何额外的检查，直接处理业务逻辑并返回数据。这样就享受了本地验证的高性能。
   - **对于高风险操作**：
     - **例子**：一个给用户信用卡扣款、转账或删除服务器的API。
     - **决策**：**“我绝对不能在一个已被撤销的令牌授权下执行这个操作！我需要100%确认它的实时有效性。”**
     - 动作：这个API端点，在执行核心业务逻辑之前，会额外地、主动地去调用授权服务器的令牌内省端点，进行一次远程验证。
       - 如果内省结果是`"active": false`，API会立即拒绝请求。
       - 如果内省结果是`"active": true`，API才继续执行扣款等敏感操作。

------

### 这种混合方法的巨大优势

- 兼顾性能与安全：
  - **99%\**的请求（假设大部分是低风险操作）都能享受到本地验证带来的\**高性能**。
  - 只有那**1%\**的、极其关键的高风险操作，才需要付出远程内省的\**性能代价**，来换取**绝对的安全性**。
- 资源优化：
  - 大大减少了对授权服务器内省端点的调用次数，避免了其成为系统瓶颈。
  - 网关分担了绝大部分的验证负载和垃圾流量过滤工作。
- 逻辑解耦：
  - 基础的令牌验证逻辑（格式、签名、有效期）可以统一在网关层面实现。
  - 具体的、与业务风险相关的深度验证逻辑，则下放到各自的API服务中，使得权责更加清晰。