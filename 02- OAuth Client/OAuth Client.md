## 客户端开发者 (Client Developer)

几种典型的应用场景：

1. **传统Web服务器应用 (Web Server Apps)**
   - **环境**：代码运行在后端服务器上（用Java, Python, PHP等编写）。
   - **特点**：是**机密客户端 (Confidential Client)**，能够安全保管`client_secret`。
2. **单页应用 (Single-Page JavaScript Apps - SPA)**
   - **环境**：代码运行在用户的浏览器里（用React, Vue, Angular等编写）。
   - **特点**：是**公共客户端 (Public Client)**，无法保管秘密。
3. **原生移动应用 (Mobile Phone Apps)**
   - **环境**：代码运行在用户的手机上（iOS, Android）。
   - **特点**：也是**公共客户端 (Public Client)**。
4. **无浏览器设备应用 (Browserless Devices)**
   - **环境**：运行在像Apple TV、智能家电等没有标准浏览器的设备上。
   - **特点**：需要一种特殊的流程，因为用户无法直接在设备上输入密码。
5. **无最终用户应用 (Machine-to-Machine - M2M)**
   - **环境**：一个后台服务需要去访问另一个后台服务的API，整个过程**没有人类用户参与**。比如，一个定时任务脚本需要去调用数据分析API。
   - **特点**：需要一种完全不同的、非交互式的授权流程。

### 视角限定：我们只关心“客户端该做什么”

为了让学习更有针对性，这部分课程会有意地“忽略”一些事情：

- **忽略授权服务器的内部实现**：我们不关心授权服务器（如Keycloak, Google）内部是如何生成令牌、管理会话的。我们把它当成一个“黑盒”。
- **忽略你无法控制的策略**：比如`access_token`的生命周期是多长（1小时还是10分钟？）。这是由授权服务器决定的，作为客户端开发者，你只能接受并遵守。
- **暂时不深入令牌格式**：我们暂时不关心`access_token`内部到底长什么样，是JWT还是其他格式。我们只把它当成一个需要传递给API的字符串。

这些被忽略的内容，会在之后进行解释，当我们转换视角，变成“**API开发者 (API Developer)**”时，再进行深入探讨。

### 举例说明

假设我们开发的是一个游戏运维平台

#### 1. 前端开发者 (开发“公共客户端”)

- **你正在开发的东西**：一个运行在浏览器里的**单页应用 (SPA)**，也就是你的运维平台的**用户界面**。这个界面是用Vue, React, Angular或纯JavaScript编写的。
- **它的角色 (OAuth术语)**：**公共客户端 (Public Client)**。
- 作为这个角色的开发者，你的核心任务是：
  1. **实现登录流程**：编写JavaScript代码，使用像`keycloak-js`这样的库，在用户点击“登录”时，正确地将浏览器重定向到Keycloak，并处理好**PKCE**（`code_challenge`和`code_verifier`）的生成和发送。
  2. **处理重定向**：编写代码来处理从Keycloak重定向回来的请求，从URL中安全地提取`code`。
  3. **交换并管理令牌**：让你的JS代码在后台（后通道）用`code`和`code_verifier`去Keycloak交换`access_token`和`refresh_token`。
  4. **安全存储令牌**：将获取到的令牌安全地存储在浏览器中（通常在内存中，而不是localStorage）。
  5. **在API请求中附加令牌**：确保每一次向你的FastAPI后端发起的API请求，都在`Authorization`头里正确地附带上`Bearer <access_token>`。
  6. **处理令牌刷新和会话管理**：编写逻辑来处理`access_token`过期后的静默刷新，以及用户的登出操作。

**简单说，你作为“前端客户端开发者”，关心的是如何与授权服务器（Keycloak）进行安全的、面向用户的交互，拿到“通行证”（令牌）。**

#### 2. 后端开发者 (开发“资源服务器”的保护逻辑)

- **你正在开发的东西**：你的**FastAPI后端应用**，它提供所有实际的运维操作API（如重启服务器、查询日志等）。
- **它的角色 (OAuth术语)**：**资源服务器 (Resource Server)**。
- 作为这个角色的开发者，你的核心任务是：
  1. **保护API端点**：为你的每个API路由（Route）添加安全依赖（`Depends`），声明它是一个受保护的资源。
  2. 实现令牌验证：编写一个可重用的依赖项（函数），它能够：
     - 从请求头中提取`Bearer Token`。
     - 连接到Keycloak的JWKS端点获取公钥。
     - 使用公钥验证令牌的**签名**、**有效期**、**签发者(issuer)\**和\**接收者(audience)**，确保令牌是真实、有效且发给自己的。
  3. **实现权限检查**：在验证令牌成功后，进一步检查令牌中包含的**角色/权限信息**（`realm_access.roles`）。
  4. **编写授权逻辑**：根据API端点的要求，判断令牌中的角色是否满足访问条件（比如，`/servers/reboot`接口必须要求令牌里有`game-admin`角色）。

**简单说，你作为“后端资源服务器开发者”，关心的是如何识别和验证前端送来的“通行证”，并根据通行证上的“身份等级”（角色）来决定是否放行。**